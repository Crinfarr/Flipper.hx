package flip;

import haxe.Exception;
import haxe.xml.Access;
#if macro
import sys.io.File;
import haxe.macro.Expr.Field;
import haxe.macro.Expr.Error;
import haxe.macro.Context;
#end

@:autoBuild(App.requireManifest())
@:autoBuild(App.compileManifest())
class App {
	private static macro function requireManifest():Array<Field> {
		final fields = Context.getBuildFields();
		final extclass = Context.getLocalClass();
		if (extclass != null && !extclass.get().meta.has(':manifest')) {
			throw new Error('App declarations must contain @:manifest("[xmlpath]") metadata', Context.currentPos());
		} else {
			return fields;
		}
	}

	private static macro function compileManifest():Array<Field> {
		final lclass = Context.getLocalClass().get();
		final metaentries = lclass.meta.extract(':manifest');
		final path = metaentries.map((entry) -> {
			switch (entry.params[0].expr) {
				case EConst(c):
					switch (c) {
						case CString(s, _kind):
							return s;
						default:
							throw new Error('Invalid argument type for @:manifest(path)', Context.currentPos());
					}
				default:
					throw new Error('Invalid type for @:manifest(path) entry', Context.currentPos());
			}
		})[0];
		final fc = File.getContent(path);
		final xmlContent = new Access(Xml.parse(fc));
		final ofile = File.write('app.fam', false);
		final appnode = xmlContent.node.app;
		ofile.writeString('# Generated by HxFlipper
App(
    appid="${xmlContent.node.app.att.id}",
    apptype=FlipperAppType.${xmlContent.node.app.att.type},
    ${!appnode.hasNode.name ? "#" : ""}name="${appnode.node.name.innerData}",
    ${!appnode.hasNode.entrypoint ? "#" : ""}entry_point="${appnode.node.entrypoint.innerData}",
    ${!appnode.hasNode.flags ? "#flags=[]" : throw new Error('DO NOT USE FLAGS', cast {min:0, max:0, file: path})},
    ${!appnode.hasNode.cdefines ? "#" : ""}${parseSubnodeAttributes(appnode.node.cdefines, "cdefines", "name")},
    ${!appnode.hasNode.requires ? "#" : ""}${parseSubnodeAttributes(appnode.node.requires, "requires", "id")},
    ${!appnode.hasNode.conflicts ? "#" : ""}${parseSubnodeAttributes(appnode.node.conflicts, "conflicts", "id")},
    ${!appnode.hasNode.provides ? "#" : ""}${parseSubnodeAttributes(appnode.node.provides, "provides", "name")},
    ${!appnode.hasNode.stacksize ? "#" : ""}${numericSubnode(appnode.node.stacksize.innerData, "stack_size")},
    ${!appnode.hasNode.icon ? "#" : ""}icon="${noNullAtt(appnode.node.icon, "path")}",
    ${!appnode.hasNode.order ? "#" : ""}${numericSubnode(appnode.node.order.innerData, "order")},
    ${!appnode.hasNode.sdkheaders ? "#" : ""}${parseSubnodeAttributes(appnode.node.sdkheaders, "sdk_headers", "path")},
    ${!appnode.hasNode.targets ? "#" : ""}targets=["${noNullInner(appnode.node.targets)}"],
    ${!appnode.hasNode.resources ? "#" : ""}resources="${noNullAtt(appnode.node.resources, "path")}",
    ${!appnode.hasNode.sources ? "#" : ""}${parseSubnodeAttributes(appnode.node.sources, "sources", "path")},
    ${!appnode.hasNode.appversion ? "#" : ""}fap_version=${tuplify(appnode.node.appversion.innerData)},
    ${!appnode.hasNode.appicon ? "#" : ""}fap_icon="${noNullAtt(appnode.node.appicon, "path")}",
    ${!appnode.hasNode.applibs ? "#" : ""}${parseSubnodeAttributes(appnode.node.appLibs, "fap_libs", "id")},
    ${!appnode.hasNode.appcategory ? "#" : ""}fap_category="${noNullInner(appnode.node.appcategory)}",
    ${!appnode.hasNode.appdescription ? "#" : ""}fap_description="${noNullInner(appnode.node.appdescription)}",
    ${!appnode.hasNode.appauthor ? "#" : ""}fap_author="${noNullInner(appnode.node.appauthor)}",
    ${!appnode.hasNode.appurl ? "#" : ""}fap_weburl="${noNullInner(appnode.node.appurl)}",
    ${!appnode.hasNode.appiconassets ? "#" : ""}fap_icon_assets="${noNullAtt(appnode.node.appiconassets, "path")}",
    ${!appnode.hasNode.extbuild ? "#" : ""}${extbuilds(appnode.node.extbuild)},
    ${!appnode.hasNode.embedded ? "#" : ""}fal_embedded=${noNullInner(appnode.node.embedded)},
)');
        ofile.close();
		return Context.getBuildFields(); // doesn't actually touch builds
	}

	#if macro
    //TODO refactor to static extension (reusable)
    private static function extbuilds(node:Access) {
        if (node == null) return 'fap_extbuild=[]';
        var rv = 'fap_extbuild=[';
        for (element in node.elements) {
            rv += 'ExtFile(path="${element.att.path}", command="${element.att.command}"),';
        }
        rv += ']';
        return rv;
    }
	private static function noNullAtt(node:Access, att:String):String {
		if (node == null)
			return "";
		return node.att.resolve(att);
	}

	private static function noNullInner(node:Access):String {
		if (node == null)
			return "";
		return node.innerData;
	}

	private static function tuplify(val:String):String {
		final reg = ~/([0-9]+)\\.([0-9]+)/gm;
		if (!reg.match(val))
			throw 'Invalid version string, must be a.b';
		return '(${reg.matched(1)},${reg.matched(2)})';
	}

	private static function numericSubnode(val:String, basename:String):String {
		final v = Std.parseInt(val);
		if (v == null)
			return '$basename=0';
		return '$basename=$v';
	}

	private static function parseSubnodeAttributes(node:Access, basename:String, attName:String) {
		if (node == null)
			return '$basename=[]';
		var rv = '$basename=[';
		for (element in node.elements) {
			rv += '"${element.att.resolve(attName)}"';
		}
		return rv;
	}
	#end

	public function new() {}
}
